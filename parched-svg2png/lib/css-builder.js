// Generated by CoffeeScript 1.8.0
var CSSBuilder, Eco, Fs, Path;

Fs = require('fs');

Path = require('path');

Eco = require('eco');

module.exports = CSSBuilder = (function() {
  CSSBuilder.prototype.supportedStates = ['hover', 'target', 'active', 'focus'];

  CSSBuilder.prototype.supportedPreprocessors = ['css', 'sass', 'scss'];

  function CSSBuilder(optionsClone, done) {
    this.optionsClone = optionsClone;
    this.done = done;
  }

  CSSBuilder.prototype.allDone = function() {
    return typeof this.done === "function" ? this.done.apply(this, arguments) : void 0;
  };

  CSSBuilder.prototype.build = function() {
    Fs.writeFileSync(this.optionsClone.outputCSS, this.compiled(), 'utf8');
    return this.allDone();
  };

  CSSBuilder.prototype.templateData = function() {
    var key, result, val;
    result = {
      cssClassPrefix: this.optionsClone.cssClassPrefix,
      usePlaceholderSelectors: this.optionsClone.usePlaceholderSelectors,
      spriteMap: this.normalizeSpriteMap('spriteMap'),
      spriteMap2x: this.normalizeSpriteMap('spriteMap2x')
    };
    result.leader = this.preprocessor() === 'css' ? '.' : this.optionsClone.usePlaceholderSelectors ? '%' : '.';
    result.baseclasses = (function() {
      var _ref, _results;
      _ref = result.spriteMap.coordinates;
      _results = [];
      for (key in _ref) {
        val = _ref[key];
        _results.push("." + result.cssClassPrefix + "-" + key);
      }
      return _results;
    })();
    result.baseclasses2x = (function() {
      var _ref, _results;
      _ref = result.spriteMap2x.coordinates;
      _results = [];
      for (key in _ref) {
        val = _ref[key];
        _results.push("." + result.cssClassPrefix + "-" + key);
      }
      return _results;
    })();
    result.baseclasses_joined = result.baseclasses.join(', ');
    result.baseclasses2x_joined = result.baseclasses2x.join(', ');
    return result;
  };

  CSSBuilder.prototype.compiled = function() {
    var compiled, templateContents, templateData, templatePath;
    templateData = this.templateData();
    templateData.halved = function(n) {
      return Math.ceil(n / 2);
    };
    templatePath = this.templatePath(this.preprocessor());
    templateContents = Fs.readFileSync(templatePath, 'utf8');
    compiled = Eco.render(templateContents, templateData);
    return compiled.replace(/(\r?\n){2,}/g, "\n\n").trim();
  };

  CSSBuilder.prototype.templatePath = function(template) {
    var relative;
    relative = Path.join(__dirname, '..', 'templates', "template." + template + ".eco");
    return Path.normalize(relative);
  };

  CSSBuilder.prototype.preprocessor = function() {
    var outputCSS, processor, _i, _len, _ref;
    outputCSS = this.optionsClone.outputCSS;
    _ref = this.supportedPreprocessors;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      processor = _ref[_i];
      if (RegExp("\\." + processor + "$").test(outputCSS)) {
        return processor;
      }
    }
    throw new Error("Svg2PngSprite doesn't know how to write `" + outputCSS + "`");
  };

  CSSBuilder.prototype.normalizeSpriteMap = function(mapName) {
    var basename, coords, fileName, newCoords, newFileName, oldCoords, prop, spriteIsState, spriteMap, stateName, stateRegex, _i, _j, _len, _len1, _ref, _ref1;
    spriteMap = this.optionsClone[mapName];
    spriteMap.httpPath = this.normalizeHttpPath(spriteMap.fileName);
    spriteMap.width = spriteMap.properties.width;
    spriteMap.height = spriteMap.properties.height;
    delete spriteMap.properties;
    newCoords = {};
    oldCoords = spriteMap.coordinates;
    delete spriteMap.coordinates;
    for (fileName in oldCoords) {
      coords = oldCoords[fileName];
      newFileName = this.normalizeFileName(fileName);
      spriteIsState = false;
      _ref = this.supportedStates;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stateName = _ref[_i];
        stateRegex = RegExp("-" + stateName);
        if (stateRegex.test(newFileName)) {
          spriteIsState = true;
          basename = newFileName.replace(stateRegex, '');
          if (newCoords[basename] == null) {
            newCoords[basename] = {};
          }
          newCoords[basename][stateName] = coords;
        }
      }
      if (spriteIsState) {
        continue;
      }
      if (newCoords[newFileName] == null) {
        newCoords[newFileName] = {};
      }
      _ref1 = ['x', 'y', 'width', 'height'];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        prop = _ref1[_j];
        newCoords[newFileName][prop] = coords[prop];
      }
    }
    spriteMap.coordinates = newCoords;
    return spriteMap;
  };

  CSSBuilder.prototype.normalizeFileName = function(fileName) {
    return fileName.replace('tmp/parched-svg2png/', '').replace('.png', '').replace('/', '_').replace('-2x', '');
  };

  CSSBuilder.prototype.normalizeHttpPath = function(filename) {
    var basename;
    basename = Path.basename(filename);
    return this.optionsClone.httpImagesPath + basename;
  };

  return CSSBuilder;

})();
