// Generated by CoffeeScript 1.8.0
var Async, CSSBuilder, Fs, JOB_LIMIT, Mkdirp, Path, Svgo, UNICODE_PUA_START, types;

Path = require('path');

Svgo = require('svgo');

Async = require('async');

Fs = require('fs');

Mkdirp = require('mkdirp');

CSSBuilder = require('./css-builder');

types = ['eot', 'woff', 'ttf', 'svg'];

UNICODE_PUA_START = 0xF101;

JOB_LIMIT = require('os').cpus().length;

module.exports = function(Parched) {
  return Parched.createPlugin({
    displayName: 'parched-webfont',
    src: '*.svg',
    shouldProcessAssets: function() {
      return true;
    },
    getDefaultOptions: function() {
      return {
        engine: 'node',
        src: 'glyphs/**/*.svg',
        dest: 'public/fonts',
        outputCSS: 'app/styles/glyphs.css',
        cssClassPrefix: 'icon',
        svgoOptions: {},
        codepoints: {},
        glyphs: void 0,
        usePlaceholderSelectors: true,
        fontBaseName: 'icons',
        fontName: 'icons',
        httpFontsPath: 'fonts',
        outputDirectory: 'fonts',
        addHashes: true,
        addLigatures: false,
        types: types,
        order: types,
        rename: Path.basename,
        autoHint: true,
        startCodepoint: UNICODE_PUA_START,
        normalize: true,
        fontHeight: 512,
        descent: 64,
        ascent: 448
      };
    },
    transform: function(context) {
      var optionsClone;
      optionsClone = Parched.vendor.xtend({}, this.options);
      optionsClone.files = [];
      return this.processManyFiles(optionsClone.src, context, this.__preprocess(optionsClone));
    },
    __preprocess: function(optionsClone) {
      return (function(_this) {
        return function(files, done) {
          var file, svgPreprocessTasks, svgoInstance, tmpDir, _i, _len;
          optionsClone.done = done;
          svgPreprocessTasks = [];
          svgoInstance = new Svgo(optionsClone.svgoOptions);
          tmpDir = 'tmp/parched-webfont';
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            svgPreprocessTasks.push((function(file) {
              return function(asyncCallback) {
                var svgContents;
                svgContents = file.contents.toString();
                return svgoInstance.optimize(svgContents, function(result) {
                  var svgBaseName, tmpFileName;
                  svgBaseName = Path.basename(file.path);
                  tmpFileName = Path.join(tmpDir, svgBaseName);
                  Mkdirp.sync(tmpDir);
                  Fs.writeFileSync(tmpFileName, result.data);
                  optionsClone.files.push(tmpFileName);
                  return asyncCallback();
                });
              };
            })(file));
          }
          return Async.parallelLimit(svgPreprocessTasks, JOB_LIMIT, _this.__build(optionsClone));
        };
      })(this);
    },
    __build: function(optionsClone) {
      return (function(_this) {
        return function(err) {
          var engine;
          if (err) {
            return optionsClone.done(err);
          }
          _this.__buildGlyphList(optionsClone);
          _this.__buildCodepointList(optionsClone);
          Mkdirp.sync(optionsClone.dest);
          engine = require("grunt-webfont/tasks/engines/" + optionsClone.engine);
          return engine(optionsClone, function(data) {
            var cssBuilder;
            if (data === false) {
              return optionsClone.done(new Error("Could not build font using " + optionsClone.engine));
            }
            if (typeof data === 'function') {
              optionsClone.fontNameWithHash = optionsClone.fontName;
              optionsClone.fontName = optionsClone.fontBaseName;
            } else {
              optionsClone.fontNameWithHash = data.fontName;
            }
            optionsClone.done();
            cssBuilder = new CSSBuilder(optionsClone, optionsClone.done);
            return cssBuilder.build();
          });
        };
      })(this);
    },
    __buildGlyphList: function(optionsClone) {
      var fileName;
      if (optionsClone.glyphs == null) {
        optionsClone.glyphs = (function() {
          var _i, _len, _ref, _results;
          _ref = optionsClone.files;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            fileName = _ref[_i];
            _results.push(optionsClone.rename(fileName).replace(Path.extname(fileName), ''));
          }
          return _results;
        })();
      }
      return null;
    },
    __buildCodepointList: function(optionsClone) {
      var name, _base, _i, _len, _ref;
      _ref = optionsClone.glyphs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        if ((_base = optionsClone.codepoints)[name] == null) {
          _base[name] = UNICODE_PUA_START++;
        }
      }
      return null;
    }
  });
};
